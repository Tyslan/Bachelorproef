\chapter{Data modellering in Cassandra}
\label{ch:cassandra_modelling}
\section{Primaire sleutel}
Binnen de primaire sleutel in Cassandra worden de partitie (\ref{partition_key}) en clustering (\ref{partition_key}) sleutels vastgelegd voor een tabel.
In tegenstelling tot relationele databases dient de primaire sleutel hier niet als unieke sleutel voor de rij maar om snel te weten te komen waar de data zich bevindt \citep{kan2014cassandra}.
Als een tabel slechts één kolom heeft als primaire sleutel dan is deze kolom meteen ook de partitie sleutel en zijn er geen clustering kolommen.

Door het feit dat de primaire sleutel in Cassandra niet uniek hoeft te zijn gedragen het INSERT commando en het UPDATE commando zich op een identieke wijze.
Een nadeel hierbij is dat er geen waarschuwing wordt gegeven als er rij overschreven wordt.
Omdat dit veelal ongewenst gedrag is binnen applicaties komt men al snel terecht bij een samengestelde primaire sleutel, een primaire sleutel uit verschillende kolommen.

\section{Partitie sleutel}
\label{partition_key}
Het doel van de partitie sleutel is om de data gebalanceerd over alle nodes te spreiden.
Op deze manier kan de fysieke locatie van de data ook snel achterhaalt worden \citep{kan2014cassandra}.
De partitie sleutel kan eveneens meerdere kolommen omvatten.

Bij het kiezen van de partitie sleutel dient er met een aantal zaken rekening gehouden te worden om de data evenwichtig over alle nodes te spreiden, maar er is slechts één fysische restrictie.
Iedere rij kan slechts 2 miljard kolommen bevatten \citep{McFadin2013Timeseries}.
In de meeste gevallen is dit ruim voldoende.
Tijdsreeksen vormen hier een uitzondering op.
Deze reeksen kunnen al gauw miljarden entries bevatten.
Hier is het dus zeer belangrijk om een goede partitie sleutel te kiezen of men komt hier al snel in de problemen.

\section{Clustering sleutel}
\label{clustering_key}
Het doel van clustering sleutels is om de data te clusteren binnen een partitie.

\section{De WHERE clausule}
Zoals \cite{Lerer2015Where} aanhaalt is een van de grootste verschillen tussen CQL en SQL de WHERE clausule.
In SQL kent de WHERE clausule geen restricties.
Bij CQL is dit anders.
Hier worden restricties opgelegd door de partitie en clustering sleutel.

\subsection{Restricties opgelegd door de partitie sleutels}

Een eerste restrictie die wordt opgelegd door de partitie sleutel is dat ofwel alle partitie sleutels worden opgenomen in de WHERE clausule ofwel geen enkel.
Indien er te weinig 
Dit is nodig omdat Cassandra anders de hash niet kan berekenen.
Deze hash is echter nodig om te weten op welke node de data zich bevind.

Een volgende restrictie die wordt opgelegd door de partitie sleutel is het feit dat enkel de '=' en IN operator rechtstreeks gebruikt kunnen worden.
Tot Cassandra 2.2 kon zelfs de IN operator enkel op de laatste kolom van de partitie sleutel.

De laatste restrictie die wordt opgelegd door de partitie sleutels heeft te maken met de >, >=, < en <= operators.
Deze zijn enkel rechtstreeks toepasbaar als de partitioner ingesteld op ByteOrderedPartitioner.
Indien dit niet het geval is moet men een omweg maken via de token functie.
Op het eerste zicht lijkt het gebruik van de token functie minder efficiënt voor het selecteren van data, maar dit weegt niet op tegen de nadelen die ByteOrderedPartitioner heeft op gebied van de distributie van de data, zoals reeds eerder werd vermeld.

\subsection{Restricties opgelegd door de clustering sleutels}
Voor de restricties op de clustering sleutel uitgelegd kunnen worden moet eerst uitgelegd worden hoe de data in Cassandra binnen een partitie opgeslagen wordt.
Dit zal nu aan de hand van een voorbeeld uitgelegd worden \citep{Lerer2015Where}.
Neem de onderstaande tabel:

\begin{lstlisting}
CREATE TABLE NumberOfTwitterMessages (
  userid bigint, date text, hour int, minute int,
  nrOfTweets int,
  PRIMARY KEY  ((userid, date), hour, minute)
);
\end{lstlisting}

Hier wordt de data nu als volgt opgeslagen binnen de partitie: 

\begin{lstlisting}
{hour: 20 
  {minute: 4 {nrOfTweets: 6}} 
  {minute: 7 {nrOfTweets: 1}}
  {minute: 21 {nrOfTweets: 16}}
  ...
}
\end{lstlisting}

De eerste restrictie wordt hier opgelegd door de manier waarop de data opgeslagen zit.
Als men een voorwaarde wil vastleggen voor een clustering kolom, dan dienen de clustering kolommen die voor deze komen in de primaire sleutel ook vastgelegd te worden.
Dit is nodig omdat Cassandra de data anders niet efficiënt kan terugvinden.

Tot Cassandra 2.2 was de IN operator enkel toegelaten op de laatste clustering kolom.
Sinds Cassandra 2.2 is deze restrictie vervallen en kan men nu zelf multi-kolom IN restricties opleggen.

De >, >=, < en <= operators ook enkel toegestaan op de laatste clustering kolom waar een restrictie is aan opgelegd.
Toch is hier een oplossing voor aangezien men deze operators kan toepassen over meerdere kolommen.
Bij deze multi-column slices is het echter wel belangrijk dat de restrictie van de WHERE clausule met dezelfde kolom start.